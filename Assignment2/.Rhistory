comb = 0
for (i in 1:max_lag){
comb = comb + CombN(max_lag,i)
}
lag_struc <- matrix(,nrow = comb, ncol =max_lag)
lag_max <- rep(0, comb)
# Lag 1
lag_n = 1
for (i in 1:length(comb_set[[lag_n]])){
lag = comb_set[[lag_n]][i]
lag_struc[start + i,lag] = 0
lag_max[start + i] = lag
}
# Lag 2 and higher
start = 0
for (n in 2:max_lag){
lag_n = n
start = start + length(comb_set[[lag_n-1]][,1])
for (i in 1:length(comb_set[[lag_n]][,1])){
for (j in 1:lag_n){
lag = comb_set[[lag_n]][i,j]
lag_struc[start + i,lag] = 0
}
lag_max[start + i] = max(comb_set[[lag_n]][i,])
}
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Set combinatorics
max_lag = 5
lag <- c(1:max_lag)
comb_set <- CombSet(lag, m=1:max_lag)
comb = 0
for (i in 1:max_lag){
comb = comb + CombN(max_lag,i)
}
lag_struc <- matrix(,nrow = comb, ncol =max_lag)
lag_max <- rep(0, comb)
# Lag 1
lag_n = 1
for (i in 1:length(comb_set[[lag_n]])){
lag = comb_set[[lag_n]][i]
lag_struc[start + i,lag] = 0
lag_max[start + i] = lag
}
rm(list = ls())
# Set combinatorics
max_lag = 5
lag <- c(1:max_lag)
comb_set <- CombSet(lag, m=1:max_lag)
comb = 0
for (i in 1:max_lag){
comb = comb + CombN(max_lag,i)
}
lag_struc <- matrix(,nrow = comb, ncol =max_lag)
lag_max <- rep(0, comb)
# Lag 1
lag_n = 1
for (i in 1:length(comb_set[[lag_n]])){
lag = comb_set[[lag_n]][i]
lag_struc[start + i,lag] = 0
lag_max[start + i] = lag
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Set combinatorics
max_lag = 5
lag <- c(1:max_lag)
comb_set <- CombSet(lag, m=1:max_lag)
comb = 0
for (i in 1:max_lag){
comb = comb + CombN(max_lag,i)
}
lag_struc <- matrix(,nrow = comb, ncol =max_lag)
lag_max <- rep(0, comb)
# Lag 1
lag_n = 1
for (i in 1:length(comb_set[[lag_n]])){
lag = comb_set[[lag_n]][i]
lag_struc[start + i,lag] = 0
lag_max[start + i] = lag
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Set combinatorics
max_lag = 5
lag <- c(1:max_lag)
comb_set <- CombSet(lag, m=1:max_lag)
comb = 0
for (i in 1:max_lag){
comb = comb + CombN(max_lag,i)
}
lag_struc <- matrix(,nrow = comb, ncol =max_lag)
lag_max <- rep(0, comb)
# Lag 1
lag_n = 1
for (i in 1:length(comb_set[[lag_n]])){
lag = comb_set[[lag_n]][i]
lag_struc[i,lag] = 0
lag_max[i] = lag
}
# Lag 2 and higher
start = 0
for (n in 2:max_lag){
lag_n = n
start = start + length(comb_set[[lag_n-1]][,1])
for (i in 1:length(comb_set[[lag_n]][,1])){
for (j in 1:lag_n){
lag = comb_set[[lag_n]][i,j]
lag_struc[start + i,lag] = 0
}
lag_max[start + i] = max(comb_set[[lag_n]][i,])
}
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Set combinatorics
max_lag = 7
lag <- c(1:max_lag)
comb_set <- CombSet(lag, m=1:max_lag)
comb = 0
for (i in 1:max_lag){
comb = comb + CombN(max_lag,i)
}
lag_struc <- matrix(,nrow = comb, ncol =max_lag)
lag_max <- rep(0, comb)
# Lag 1
lag_n = 1
for (i in 1:length(comb_set[[lag_n]])){
lag = comb_set[[lag_n]][i]
lag_struc[i,lag] = 0
lag_max[i] = lag
}
# Lag 2 and higher
start = 0
for (n in 2:max_lag){
lag_n = n
start = start + length(comb_set[[lag_n-1]][,1])
for (i in 1:length(comb_set[[lag_n]][,1])){
for (j in 1:lag_n){
lag = comb_set[[lag_n]][i,j]
lag_struc[start + i,lag] = 0
}
lag_max[start + i] = max(comb_set[[lag_n]][i,])
}
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Set combinatorics
max_lag = 5
lag <- c(1:max_lag)
comb_set <- CombSet(lag, m=1:max_lag)
comb = 0
for (i in 1:max_lag){
comb = comb + CombN(max_lag,i)
}
lag_struc <- matrix(,nrow = comb, ncol =max_lag)
lag_max <- rep(0, comb)
# Lag 1
lag_n = 1
for (i in 1:length(comb_set[[lag_n]])){
lag = comb_set[[lag_n]][i]
lag_struc[i,lag] = 0
lag_max[i] = lag
}
# Lag 2 and higher
start = 0
for (n in 2:max_lag){
lag_n = n
start = start + length(comb_set[[lag_n-1]][,1])
for (i in 1:length(comb_set[[lag_n]][,1])){
for (j in 1:lag_n){
lag = comb_set[[lag_n]][i,j]
lag_struc[start + i,lag] = 0
}
lag_max[start + i] = max(comb_set[[lag_n]][i,])
}
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Load data
data <- read.csv("data_assign_p3.csv")
View(data)
data$DATE<- as.Date(data$DATE, format = "%d/%m/%Y")
lag_struc[1]
lag_struc[,1]
lag_struc[1,]
arima(x=data$APPLE, order = c(lag_max[1],0,0), fixed = lag_struc[1,])
arima(x=data$APPLE, order = c(max_lag,0,0), fixed = lag_struc[1,])
max_lag
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Set combinatorics where 1 is intercept and 2-x are auto lags of order (-1)
max_lag = 6
lag <- c(1:max_lag)
comb_set <- CombSet(lag, m=1:max_lag)
comb = 0
for (i in 1:max_lag){
comb = comb + CombN(max_lag,i)
}
lag_struc <- matrix(,nrow = comb, ncol =max_lag)
lag_max <- rep(0, comb)
# Lag 1
lag_n = 1
for (i in 1:length(comb_set[[lag_n]])){
lag = comb_set[[lag_n]][i]
lag_struc[i,lag] = 0
lag_max[i] = lag
}
# Lag 2 and higher
start = 0
for (n in 2:max_lag){
lag_n = n
start = start + length(comb_set[[lag_n-1]][,1])
for (i in 1:length(comb_set[[lag_n]][,1])){
for (j in 1:lag_n){
lag = comb_set[[lag_n]][i,j]
lag_struc[start + i,lag] = 0
}
lag_max[start + i] = max(comb_set[[lag_n]][i,])
}
}
arima(x=data$APPLE, order = c(max_lag,0,0), fixed = lag_struc[1,])
arima(x=ts, order = c(lag_max[i],0,0), fixed = lag_struc[1,])
lag_struc[1,]
install.packages("naniar")
library(naniar)
replace_with_na()
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Set combinatorics where 1 is intercept and 2-x are auto lags of order (-1)
max_lag = 6
lag <- c(1:max_lag)
comb_set <- CombSet(lag, m=1:max_lag)
comb = 0
for (i in 1:max_lag){
comb = comb + CombN(max_lag,i)
}
lag_struc <- matrix(0,nrow = comb, ncol =max_lag)
lag_max <- rep(0, comb)
# Lag 1
lag_n = 1
for (i in 1:length(comb_set[[lag_n]])){
lag = comb_set[[lag_n]][i]
lag_struc[i,lag] = NA
lag_max[i] = lag
}
# Lag 2 and higher
start = 0
for (n in 2:max_lag){
lag_n = n
start = start + length(comb_set[[lag_n-1]][,1])
for (i in 1:length(comb_set[[lag_n]][,1])){
for (j in 1:lag_n){
lag = comb_set[[lag_n]][i,j]
lag_struc[start + i,lag] = NA
}
lag_max[start + i] = max(comb_set[[lag_n]][i,])
}
}
arima(x=data$APPLE, order = c(max_lag -1,0,0), fixed = lag_struc[1,])
arima(x=data$APPLE, order = c(1,0,0))
arima(x=data$APPLE, order = c(1,0,0))$aic
arima(x=data$APPLE, order = c(2,0,0), fixed = c(0,NA,NA))
arima(x=data$APPLE, order = c(2,0,0))
arima(x=data$APPLE, order = c(2,0,0), fixed = c(NA,0,NA))
arima(x=data$APPLE, order = c(2,0,0), fixed = c(NA,0,NA),method = "CSS")
arima(x=data$APPLE, order = c(5,0,0), fixed = lag_struc[1,],method = "CSS")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC
ts <- data$APPLE
aics <- rep(0, comb)
for (i in 1:comb){
aics[i] <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[1,], method ="CSS")$aic
}
arima(x=data$APPLE, order = c(5,0,0), fixed = lag_struc[1,],method = "CSS")
arima(x=data$APPLE, order = c(5,0,0), fixed = lag_struc[1,],method = "CSS")$aic
arima(x=data$APPLE, order = c(5,0,0), fixed = lag_struc[1,],method = "CSS-ML")
arima(x=data$APPLE, order = c(1,0,0))$aic
arima(x=data$APPLE, order = c(1,0,0))
arima(x=data$APPLE, order = c(1,0,0),method="CSS")
test <- arima(x=data$APPLE, order = c(5,0,0), fixed = lag_struc[1,],method = "CSS-ML")
test <- arima(x=data$APPLE, order = c(1,0,0),method="CSS")
View(test)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC
ts <- data$APPLE
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC
ts <- data$APPLE
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
max(aics)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC
ts <- data$APPLE
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
which.max(aics)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC
ts <- data$APPLE
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.max(aics),], method ="CSS")
View(lag_struc)
lag_struc <- lag_struc(1:5,6:comb)
lag_struc <- lag_struc[1:5,6:comb]
lag_struc <- lag_struc[-6]
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Set combinatorics where 1 last lag is intercept
max_lag = 6
lag <- c(1:max_lag)
comb_set <- CombSet(lag, m=1:max_lag)
comb = 0
for (i in 1:max_lag){
comb = comb + CombN(max_lag,i)
}
lag_struc <- matrix(0,nrow = comb, ncol =max_lag)
lag_max <- rep(0, comb)
# Lag 1
lag_n = 1
for (i in 1:length(comb_set[[lag_n]])){
lag = comb_set[[lag_n]][i]
lag_struc[i,lag] = NA
lag_max[i] = lag
}
# Lag 2 and higher
start = 0
for (n in 2:max_lag){
lag_n = n
start = start + length(comb_set[[lag_n-1]][,1])
for (i in 1:length(comb_set[[lag_n]][,1])){
for (j in 1:lag_n){
lag = comb_set[[lag_n]][i,j]
lag_struc[start + i,lag] = NA
}
lag_max[start + i] = max(comb_set[[lag_n]][i,])
}
}
# Delete model with only intercept
lag_struc <- lag_struc[-6,]
lag_max[-6]
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC
ts <- data$APPLE
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
# Set combinatorics where 1 last lag is intercept
max_lag = 6
lag <- c(1:max_lag)
comb_set <- CombSet(lag, m=1:max_lag)
comb = 0
for (i in 1:max_lag){
comb = comb + CombN(max_lag,i)
}
lag_struc <- matrix(0,nrow = comb, ncol =max_lag)
lag_max <- rep(0, comb)
# Lag 1
lag_n = 1
for (i in 1:length(comb_set[[lag_n]])){
lag = comb_set[[lag_n]][i]
lag_struc[i,lag] = NA
}
# Lag 2 and higher
start = 0
for (n in 2:max_lag){
lag_n = n
start = start + length(comb_set[[lag_n-1]][,1])
for (i in 1:length(comb_set[[lag_n]][,1])){
for (j in 1:lag_n){
lag = comb_set[[lag_n]][i,j]
lag_struc[start + i,lag] = NA
}
}
}
# Delete model with only intercept
lag_struc <- lag_struc[-max_lag,]
comb = comb -1
# Estimate all models and pick specification with highest AIC
ts <- data$APPLE
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.max(aics),], method ="CSS")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC
ts <- data$APPLE
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
max(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.max(aics),], method ="CSS")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - EXXON_MOBIL
ts <- data$EXXON_MOBIL
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
max(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.max(aics),], method ="CSS")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - FORD
ts <- data$FORD
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
max(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.max(aics),], method ="CSS")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - GEN_ELECTRIC
ts <- data$GEN_ELECTRIC
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
max(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.max(aics),], method ="CSS")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - INTEL
ts <- data$INTEL
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
max(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.max(aics),], method ="CSS")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - MICROSOFT
ts <- data$MICROSOFT
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
max(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.max(aics),], method ="CSS")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - NETFLIX
ts <- data$NETFLIX
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
max(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.max(aics),], method ="CSS")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - NOKIA
ts <- data$NOKIA
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
max(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.max(aics),], method ="CSS")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - SP500
ts <- data$SP500
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
max(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.max(aics),], method ="CSS")
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - YAHOO
ts <- data$YAHOO
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
max(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.max(aics),], method ="CSS")
