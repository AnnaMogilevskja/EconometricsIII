logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
# Estimate all models and pick specification with lowest AIC - CONS
ts <- data$CONS
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
struc <- head(struc,-1)
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta/se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
# Estimate all models and pick specification with lowest AIC - INC
ts <- data$INC
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
str(data)
# Load data
data <- read.csv("data_assign_p4.csv")
# Set combinatorics where 1 last lag is intercept
max_lag = 6
lag <- c(1:max_lag)
comb_set <- CombSet(lag, m=1:max_lag)
comb = 0
for (i in 1:max_lag){
comb = comb + CombN(max_lag,i)
}
lag_struc <- matrix(0,nrow = comb, ncol =max_lag)
lag_max <- rep(0, comb)
# Lag 1
lag_n = 1
for (i in 1:length(comb_set[[lag_n]])){
lag = comb_set[[lag_n]][i]
lag_struc[i,lag] = NA
}
# Lag 2 and higher
start = 0
for (n in 2:max_lag){
lag_n = n
start = start + length(comb_set[[lag_n-1]][,1])
for (i in 1:length(comb_set[[lag_n]][,1])){
for (j in 1:lag_n){
lag = comb_set[[lag_n]][i,j]
lag_struc[start + i,lag] = NA
}
}
}
# Delete model with only intercept
lag_struc <- lag_struc[-max_lag,]
comb = comb -1
# Estimate all models and pick specification with lowest AIC - CONS
ts <- data$CONS
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
struc <- head(struc,-1)
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta/se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
# Estimate all models and pick specification with lowest AIC - INC
ts <- data$INC
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
# Load data
data <- read.csv("data_assign_p4.csv")
# Set combinatorics where 1 last lag is intercept
max_lag = 6
lag <- c(1:max_lag)
comb_set <- CombSet(lag, m=1:max_lag)
comb = 0
for (i in 1:max_lag){
comb = comb + CombN(max_lag,i)
}
lag_struc <- matrix(0,nrow = comb, ncol =max_lag)
lag_max <- rep(0, comb)
# Lag 1
lag_n = 1
for (i in 1:length(comb_set[[lag_n]])){
lag = comb_set[[lag_n]][i]
lag_struc[i,lag] = NA
}
# Lag 2 and higher
start = 0
for (n in 2:max_lag){
lag_n = n
start = start + length(comb_set[[lag_n-1]][,1])
for (i in 1:length(comb_set[[lag_n]][,1])){
for (j in 1:lag_n){
lag = comb_set[[lag_n]][i,j]
lag_struc[start + i,lag] = NA
}
}
}
# Delete model with only intercept
lag_struc <- lag_struc[-max_lag,]
comb = comb -1
# Estimate all models and pick specification with lowest AIC - INC
ts <- data$INC
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
arima(x=ts, order = c(2,0,0), fixed = (1,0, 0, 0, 0, 0), method ="CSS")$loglik
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
View(lag_struc)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[1,], method ="CSS")$loglik
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[2,], method ="CSS")$loglik
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[3,], method ="CSS")$loglik
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[100,], method ="CSS")$loglik
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[62,], method ="CSS")$loglik
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[61,], method ="CSS")$loglik
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[60,], method ="CSS")$loglik
View(lag_struc)
# Estimate all models and pick specification with lowest AIC - INC
ts <- data$INC
aics <- rep(0, comb)
for (i in 1:comb-1){ # there is an issue with (1,1,1,1,1,1,)
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
# Estimate all models and pick specification with lowest AIC - INC
ts <- data$INC
aics <- rep(0, comb)
for (i in 1:(comb-1)){ # there is an issue with (1,1,1,1,1,1,)
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
aics
View(data)
# Estimate all models and pick specification with lowest AIC - INC
ts <- data$INC
aics <- rep(0, (comb-1))
for (i in 1:(comb-1)){ # there is an issue with (1,1,1,1,1,1,)
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
struc <- head(struc,-1)
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta/se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
data2 <- data %>%
mutate_at(vars(INS:CONS), list(~ .x - lag(.x)))
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
knitr::opts_chunk$set(echo = TRUE)
library(forecast)
library(TSstudio)
library(stringr)
library(zoo)
library(ggplot2)
library(tseries)
library(stats)
library(lmtest)
library(Metrics)
library(dynlm)
library(dLagM)
library(tsoutliers)
library(DescTools)
library(naniar)
library(tseries)
library(dplyr)
data2 <- data %>%
mutate_at(vars(INS:CONS), list(~ .x - lag(.x)))
data2 <- data %>%
mutate_at(vars(INC:CONS), list(~ .x - lag(.x)))
View(data2)
View(data)
# Estimate all models and pick specification with lowest AIC - CONS
ts <- data2$CONS
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
struc <- head(struc,-1)
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta/se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
# Estimate all models and pick specification with lowest AIC - INC
ts <- data2$INC
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
struc <- head(struc,-1)
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta/se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
test <- lm(data$CONS ~ data$INC)
test <- lm(data$CONS ~ data$INC)
summary(test)
test$coefficients[2]
test$coefficients[1]
test <- lm(data$CONS ~ data$INC)
lambda <- test$coefficients[2]
delta <- test$coefficients[1]
data$Z <- CONS - delta - lambda*INC
data$Z <- data$CONS - delta - lambda*data$INC
ar_test <- arima(data$Z, order = c(1,0,0))
coeftest(ar_test)
b <- coeftest(ar_test)
b
ar_test <- arima(data$Z, order = c(1,0,0))
coeftest(ar_test)
ar_test <- arima(data$Z, order = c(1,0,0))
DF_test <- coeftest(ar_test)
DF_Test[1,1]
DF_test[1,1]
DF_test[1,2]
DF_stat <- (DF_test[1,1]-1)/DF_test[1,2]
DF_stat
print("lambda": lambda)
print("delta": delta)
plot(data$Z)
ggplot(data, aes(obs, Z)) +
geom_point() +
geom_line() +
scale_x_yearqtr(format = fmt)
ggplot(data, aes(obs, Z)) +
geom_point() +
scale_x_yearqtr(format = fmt)
fmt <- "%YQ%q"
data$obs <- as.yearqtr(data$obs, format = fmt)
ggplot(data, aes(obs, Z)) +
geom_point() +
scale_x_yearqtr(format = fmt)
# Estimate all models and pick specification with lowest AIC - INC
ts <- data$Z
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
struc <- head(struc,-1)
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta/se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
# Estimate all models and pick specification with lowest AIC - INC
ts <- data$Z
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
struc <- head(struc,-1)
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta/se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
knitr::opts_chunk$set(echo = TRUE)
library(forecast)
library(TSstudio)
library(stringr)
library(zoo)
library(ggplot2)
library(tseries)
library(stats)
library(lmtest)
library(Metrics)
library(dynlm)
library(dLagM)
library(tsoutliers)
library(DescTools)
library(naniar)
library(tseries)
library(dplyr)
library(apt)
library(tsDyn)
library(vars)
library(urca)
library(tidyverse)
# Forecast first differences of consumption based on ECM model and forecasted values of first differences of income
h = 2
CONS <- append(rep(data2$CONS[n],1), numeric(h))
Z <- append(rep(data$Z[n],2), numeric(h))
for (i in 1:h){
j = i + 1
CONS[j] <- ecm$coefficients[1,1]*Z[j-1] + ecm$coefficients[1,2] + ecm$coefficients[1,4]*INC[j]
}
# Transform data into times seires format
tsCONS <- as.numeric(ts(data$CONS, start= c(1988, 1), end = c(2012, 1), frequency = 4))
tsINC <- as.numeric(ts(data$INC, start= c(1988, 1), end = c(2012, 1), frequency = 4))
dset <- cbind(tsCONS, tsINC)
#Selecting the Optimal Number of Lags (Recall, this is p - 1)
lagselect <- VARselect(dset, lag.max = 7, type = "const")
lagselect$selection
lagselect$criteria
# use one lag according to SIC (2-1 = 1), and co-integration order of 1 (from previous subquestion)
# estimate error correction model
ecm <- VECM(dset, 1, r = 1, estim =("2OLS"))
summary(ecm)
# Estimate an AR model for first difference of income
arINC <- arima(data2$INC, order = c(4,0,0))
arINC <- coeftest(arINC)
# Forecast first differences of income based on estimated AR model
h = 2
INC <- append(rep(data2$INC[n],1), numeric(h))
for (i in 1:h){
j = i + 1
INC[j] <- arINC[5,1] + arINC[1,1]*INC[j-1]
}
# Forecast first differences of consumption based on ECM model and forecasted values of first differences of income
h = 2
CONS <- append(rep(data2$CONS[n],1), numeric(h))
Z <- append(rep(data$Z[n],2), numeric(h))
for (i in 1:h){
j = i + 1
CONS[j] <- ecm$coefficients[1,1]*Z[j-1] + ecm$coefficients[1,2] + ecm$coefficients[1,4]*INC[j]
}
# Forecast first differences of consumption based on ECM model and forecasted values of first differences of income
h = 2
CONS2 <- append(rep(data2$CONS[n],1), numeric(h))
Z <- append(rep(data$Z[n],2), numeric(h))
for (i in 1:h){
j = i + 1
CONS2[j] <- (ecm$coefficients[1,1]/(1-ecm$coefficients[1,3]))*Z[j-1] + (ecm$coefficients[1,2]/(1-ecm$coefficients[1,3])) + (ecm$coefficients[1,4]/(1-ecm$coefficients[1,3]))*INC[j]
}
