if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = beta = summary(mod)$coefficients[1,2]
adf = beta / se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with lowest AIC - EXXON_MOBIL
ts <- data$EXXON_MOBIL
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta / se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with lowest AIC - FORD
ts <- data$FORD
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta / se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with lowest AIC - GEN_ELECTRIC
ts <- data$GEN_ELECTRIC
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta / se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with lowest AIC - INTEL
ts <- data$INTEL
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta / se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - MICROSOFT
ts <- data$MICROSOFT
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta / se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - NETFLIX
ts <- data$NETFLIX
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta / se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - NOKIA
ts <- data$NOKIA
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta / se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - SP500
ts <- data$SP500
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta / se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate all models and pick specification with highest AIC - YAHOO
ts <- data$YAHOO
aics <- rep(0, comb)
for (i in 1:comb){
logl <- arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[i,], method ="CSS")$loglik
k = sum(is.na(lag_struc[i,]))
aics[i] = 2*k - 2*logl
}
min(aics)
arima(x=ts, order = c(max_lag -1,0,0), fixed = lag_struc[which.min(aics),], method ="CSS")
# Perform ADF Test
ts <- ts(ts)
struc <- c(0)
for (i in 1:length(lag_struc[which.min(aics),]-1)){
if (is.na(lag_struc[which.min(aics),i])){
struc <- cbind(struc, i)
}
}
struc <- as.numeric(struc[,-1])
if(is.na(lag_struc[which.min(aics),i])){
int = TRUE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc))
} else{
int = FALSE
mod <- dynlm(diff(ts) ~ L(ts,1) + L(diff(ts),struc)-1)
}
beta = summary(mod)$coefficients[1,1]
se = summary(mod)$coefficients[1,2]
adf = beta / se
adf
if(int==TRUE){
adf< (-1.616)
}else{
adf< (-2.568)
}
View(comb_set)
View(data)
sum(diff(data$APPLE))
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate sigma for APPLE & MICROSOFT
sigma_apple = sum(diff(data$APPLE)^2) / (length(diff(data$APPLE)))
ts.plot(data$APPLE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
data$DATE<- as.Date(data$DATE, format = "%d/%m/%Y")
ts.plot(data$APPLE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate sigma for APPLE & MICROSOFT
sigma_aapl = sum(diff(data$APPLE)^2) / (length(diff(data$APPLE)))
sigma_msft = sum(diff(data$MICROSOFT)^2) / (length(diff(data$MICROSOFT)))
# Store last 10 observations for each stock price
hist_aapl <- tail(data$APPLE,10)
ts.plot(hist_aapl)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate sigma for APPLE & MICROSOFT
sigma_aapl = sum(diff(data$APPLE)^2) / (length(diff(data$APPLE)))
sigma_msft = sum(diff(data$MICROSOFT)^2) / (length(diff(data$MICROSOFT)))
# Store last h observations for each stock price
t = 20
hist_aapl <- tail(data$APPLE,t)
hist_msft <- tail(data$MICROSOFT,t)
# Produce forecast
h = 5
forecast_aapl <-  numeric(h)
forevast_msft <- numeric(h)
forecast_aapl[1] = tail(data$APPLE,1)
forevast_msft[1] = tail(data$MICROSOFT,1)
for (i in 2:h){
forecast_aapl[i] = forecast_aapl[i-1]
forevast_msft[i] = forevast_msft[i-1]
}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Generate plot APPLE
ts.plot(hist_aapl)
points(forecast_aapl, type="l", col=2)
points(forecast_aapl - 1.96*sqrt(sigma_aapl), type="l", col=2, lty=2)
points(forecast_aapl + 1.96*sqrt(sigma_aapl), type="l", col=2, lty=2)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate sigma for APPLE & MICROSOFT
sigma_aapl = sum(diff(data$APPLE)^2) / (length(diff(data$APPLE)))
sigma_msft = sum(diff(data$MICROSOFT)^2) / (length(diff(data$MICROSOFT)))
# Store last h observations for each stock price
t = 20
hist_aapl <- tail(data$APPLE,t)
hist_msft <- tail(data$MICROSOFT,t)
# Produce forecast
h = 5
forecast_aapl <-  numeric(h)
forevast_msft <- numeric(h)
forecast_aapl[1] = tail(data$APPLE,1)
forevast_msft[1] = tail(data$MICROSOFT,1)
for (i in 2:h){
forecast_aapl[i] = forecast_aapl[i-1]
forevast_msft[i] = forevast_msft[i-1]
}
forecast_aapl <-  ts(forecast_aapl)
forevast_msft <- ts(forecast_msft)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate sigma for APPLE & MICROSOFT
sigma_aapl = sum(diff(data$APPLE)^2) / (length(diff(data$APPLE)))
sigma_msft = sum(diff(data$MICROSOFT)^2) / (length(diff(data$MICROSOFT)))
# Store last h observations for each stock price
t = 20
hist_aapl <- tail(data$APPLE,t)
hist_msft <- tail(data$MICROSOFT,t)
# Produce forecast
h = 5
forecast_aapl <-  numeric(h)
forevast_msft <- numeric(h)
forecast_aapl[1] = tail(data$APPLE,1)
forevast_msft[1] = tail(data$MICROSOFT,1)
for (i in 2:h){
forecast_aapl[i] = forecast_aapl[i-1]
forevast_msft[i] = forevast_msft[i-1]
}
forecast_aapl <-  ts(forecast_aapl)
forecast_msft <- ts(forecast_msft)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate sigma for APPLE & MICROSOFT
sigma_aapl = sum(diff(data$APPLE)^2) / (length(diff(data$APPLE)))
sigma_msft = sum(diff(data$MICROSOFT)^2) / (length(diff(data$MICROSOFT)))
# Store last h observations for each stock price
t = 20
hist_aapl <- tail(data$APPLE,t)
hist_msft <- tail(data$MICROSOFT,t)
# Produce forecast
h = 5
forecast_aapl <-  numeric(h)
forecast_msft <- numeric(h)
forecast_aapl[1] = tail(data$APPLE,1)
forecast_msft[1] = tail(data$MICROSOFT,1)
for (i in 2:h){
forecast_aapl[i] = forecast_aapl[i-1]
forecast_msft[i] = forevast_msft[i-1]
}
forecast_aapl <-  ts(forecast_aapl)
forecast_msft <- ts(forecast_msft)
# Generate plot APPLE
ts.plot(hist_aapl)
points(forecast_aapl, type="l", col=2)
points(forecast_aapl - 1.96*sqrt(sigma_aapl), type="l", col=2, lty=2)
points(forecast_aapl + 1.96*sqrt(sigma_aapl), type="l", col=2, lty=2)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate sigma for APPLE & MICROSOFT
sigma_aapl = sum(diff(data$APPLE)^2) / (length(diff(data$APPLE)))
sigma_msft = sum(diff(data$MICROSOFT)^2) / (length(diff(data$MICROSOFT)))
# Store last h observations for each stock price
t = 20
hist_aapl <- tail(data$APPLE,t)
hist_msft <- tail(data$MICROSOFT,t)
# Produce forecast
h = 5
forecast_aapl <-  numeric(h)
forecast_msft <- numeric(h)
forecast_aapl[1] = tail(data$APPLE,1)
forecast_msft[1] = tail(data$MICROSOFT,1)
for (i in 2:h){
forecast_aapl[i] = forecast_aapl[i-1]
forecast_msft[i] = forevast_msft[i-1]
}
forecast_aapl <-  ts(forecast_aapl, start = t+1)
forecast_msft <- ts(forecast_msft, start = t+1)
# Generate plot APPLE
ts.plot(hist_aapl)
points(forecast_aapl, type="l", col=2)
points(forecast_aapl - 1.96*sqrt(sigma_aapl), type="l", col=2, lty=2)
points(forecast_aapl + 1.96*sqrt(sigma_aapl), type="l", col=2, lty=2)
ts:plot(forecast_aapl)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Estimate sigma for APPLE & MICROSOFT
sigma_aapl = sum(diff(data$APPLE)^2) / (length(diff(data$APPLE)))
sigma_msft = sum(diff(data$MICROSOFT)^2) / (length(diff(data$MICROSOFT)))
# Store last h observations for each stock price
t = 20
hist_aapl <- tail(data$APPLE,t)
hist_msft <- tail(data$MICROSOFT,t)
# Produce forecast
h = 5
forecast_aapl <-  rep( tail(data$APPLE,1),h)
forecast_msft <- rep( tail(data$MICROSOFT,1),h)
forecast_aapl <-  ts(forecast_aapl, start = t+1)
forecast_msft <- ts(forecast_msft, start = t+1)
# Generate plot APPLE
ts.plot(hist_aapl)
points(forecast_aapl, type="l", col=2)
points(forecast_aapl - 1.96*sqrt(sigma_aapl), type="l", col=2, lty=2)
points(forecast_aapl + 1.96*sqrt(sigma_aapl), type="l", col=2, lty=2)
ts.plot(forecast_aapl)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Generate plot APPLE
ts.plot(forecast_aapl)
points(forecast_aapl - 1.96*sqrt(sigma_aapl), type="l", col=2, lty=2)
points(forecast_aapl + 1.96*sqrt(sigma_aapl), type="l", col=2, lty=2)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Generate plot MICROSOFT
ts.plot(forecast_msft)
points(forecast_msft - 1.96*sqrt(sigma_aapl), type="l", col=2, lty=2)
points(forecast_msft + 1.96*sqrt(sigma_aapl), type="l", col=2, lty=2)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Generate plot MICROSOFT
ts.plot(forecast_msft)
points(forecast_msft - 1.96*sqrt(sigma_msft), type="l", col=2, lty=2)
points(forecast_msft + 1.96*sqrt(sigma_msft), type="l", col=2, lty=2)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
mod <- lm(data$APPLE ~ data$EXXON_MOBIL)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
mod <- lm(data$APPLE ~ data$EXXON_MOBIL)
summary(mod)
